// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: queries.sql

package gen

import (
	"context"
	"database/sql"
	"time"
)

const createAccessToken = `-- name: CreateAccessToken :exec
REPLACE INTO access_tokens (user_id, token, valid, chain, created_at) VALUES (?,?,?,?,?)
`

type CreateAccessTokenParams struct {
	UserID    int32
	Token     string
	Valid     int32
	Chain     string
	CreatedAt time.Time
}

func (q *Queries) CreateAccessToken(ctx context.Context, arg CreateAccessTokenParams) error {
	_, err := q.db.ExecContext(ctx, createAccessToken,
		arg.UserID,
		arg.Token,
		arg.Valid,
		arg.Chain,
		arg.CreatedAt,
	)
	return err
}

const createOAuth2Identity = `-- name: CreateOAuth2Identity :exec
INSERT INTO user_identities (user_id, provider, identity) VALUES (?,?,?)
`

type CreateOAuth2IdentityParams struct {
	UserID   int32
	Provider string
	Identity string
}

func (q *Queries) CreateOAuth2Identity(ctx context.Context, arg CreateOAuth2IdentityParams) error {
	_, err := q.db.ExecContext(ctx, createOAuth2Identity, arg.UserID, arg.Provider, arg.Identity)
	return err
}

const createRefreshToken = `-- name: CreateRefreshToken :exec
REPLACE INTO refresh_tokens (user_id, token, valid, chain, created_at) VALUES (?,?,?,?,?)
`

type CreateRefreshTokenParams struct {
	UserID    int32
	Token     string
	Valid     int32
	Chain     string
	CreatedAt time.Time
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error {
	_, err := q.db.ExecContext(ctx, createRefreshToken,
		arg.UserID,
		arg.Token,
		arg.Valid,
		arg.Chain,
		arg.CreatedAt,
	)
	return err
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO users (email, password, totp_secret, confirmed, confirm_token, recovery_token, locked_until, attempts, last_attempt) VALUES (?,?,?,?,?,?,?,?,?)
`

type CreateUserParams struct {
	Email         string
	Password      sql.NullString
	TotpSecret    sql.NullString
	Confirmed     int32
	ConfirmToken  sql.NullString
	RecoveryToken sql.NullString
	LockedUntil   sql.NullTime
	Attempts      int32
	LastAttempt   sql.NullTime
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUser,
		arg.Email,
		arg.Password,
		arg.TotpSecret,
		arg.Confirmed,
		arg.ConfirmToken,
		arg.RecoveryToken,
		arg.LockedUntil,
		arg.Attempts,
		arg.LastAttempt,
	)
}

const getAccessToken = `-- name: GetAccessToken :one
SELECT user_id, token, valid, chain, created_at FROM access_tokens WHERE user_id = ? AND token = ? LIMIT 1
`

type GetAccessTokenParams struct {
	UserID int32
	Token  string
}

func (q *Queries) GetAccessToken(ctx context.Context, arg GetAccessTokenParams) (AccessToken, error) {
	row := q.db.QueryRowContext(ctx, getAccessToken, arg.UserID, arg.Token)
	var i AccessToken
	err := row.Scan(
		&i.UserID,
		&i.Token,
		&i.Valid,
		&i.Chain,
		&i.CreatedAt,
	)
	return i, err
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT user_id, token, valid, chain, created_at FROM refresh_tokens WHERE user_id = ? AND token = ? LIMIT 1
`

type GetRefreshTokenParams struct {
	UserID int32
	Token  string
}

func (q *Queries) GetRefreshToken(ctx context.Context, arg GetRefreshTokenParams) (RefreshToken, error) {
	row := q.db.QueryRowContext(ctx, getRefreshToken, arg.UserID, arg.Token)
	var i RefreshToken
	err := row.Scan(
		&i.UserID,
		&i.Token,
		&i.Valid,
		&i.Chain,
		&i.CreatedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, username, password, totp_secret, confirmed, confirm_token, recovery_token, locked_until, attempts, last_attempt, created_at, last_login FROM users WHERE id = ? LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.TotpSecret,
		&i.Confirmed,
		&i.ConfirmToken,
		&i.RecoveryToken,
		&i.LockedUntil,
		&i.Attempts,
		&i.LastAttempt,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const getUserByConfirmationToken = `-- name: GetUserByConfirmationToken :one
SELECT id, email, username, password, totp_secret, confirmed, confirm_token, recovery_token, locked_until, attempts, last_attempt, created_at, last_login FROM users WHERE confirm_token = ? LIMIT 1
`

func (q *Queries) GetUserByConfirmationToken(ctx context.Context, confirmToken sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByConfirmationToken, confirmToken)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.TotpSecret,
		&i.Confirmed,
		&i.ConfirmToken,
		&i.RecoveryToken,
		&i.LockedUntil,
		&i.Attempts,
		&i.LastAttempt,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, username, password, totp_secret, confirmed, confirm_token, recovery_token, locked_until, attempts, last_attempt, created_at, last_login FROM users WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.TotpSecret,
		&i.Confirmed,
		&i.ConfirmToken,
		&i.RecoveryToken,
		&i.LockedUntil,
		&i.Attempts,
		&i.LastAttempt,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const getUserByOAuth2Identity = `-- name: GetUserByOAuth2Identity :one
SELECT u.id, u.email, u.username, u.password, u.totp_secret, u.confirmed, u.confirm_token, u.recovery_token, u.locked_until, u.attempts, u.last_attempt, u.created_at, u.last_login FROM users u JOIN user_identities i ON u.id = i.user_id WHERE i.provider = ? AND i.identity = ? LIMIT 1
`

type GetUserByOAuth2IdentityParams struct {
	Provider string
	Identity string
}

func (q *Queries) GetUserByOAuth2Identity(ctx context.Context, arg GetUserByOAuth2IdentityParams) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByOAuth2Identity, arg.Provider, arg.Identity)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.TotpSecret,
		&i.Confirmed,
		&i.ConfirmToken,
		&i.RecoveryToken,
		&i.LockedUntil,
		&i.Attempts,
		&i.LastAttempt,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const getUserByRecoveryToken = `-- name: GetUserByRecoveryToken :one
SELECT id, email, username, password, totp_secret, confirmed, confirm_token, recovery_token, locked_until, attempts, last_attempt, created_at, last_login FROM users WHERE recovery_token = ? LIMIT 1
`

func (q *Queries) GetUserByRecoveryToken(ctx context.Context, recoveryToken sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByRecoveryToken, recoveryToken)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.TotpSecret,
		&i.Confirmed,
		&i.ConfirmToken,
		&i.RecoveryToken,
		&i.LockedUntil,
		&i.Attempts,
		&i.LastAttempt,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, email, username, password, totp_secret, confirmed, confirm_token, recovery_token, locked_until, attempts, last_attempt, created_at, last_login FROM users WHERE username = ? LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.TotpSecret,
		&i.Confirmed,
		&i.ConfirmToken,
		&i.RecoveryToken,
		&i.LockedUntil,
		&i.Attempts,
		&i.LastAttempt,
		&i.CreatedAt,
		&i.LastLogin,
	)
	return i, err
}

const getUserPermissions = `-- name: GetUserPermissions :many
SELECT permission FROM user_permissions WHERE user_id = ?
`

func (q *Queries) GetUserPermissions(ctx context.Context, userID int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUserPermissions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var permission string
		if err := rows.Scan(&permission); err != nil {
			return nil, err
		}
		items = append(items, permission)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT role FROM user_roles WHERE user_id = ?
`

func (q *Queries) GetUserRoles(ctx context.Context, userID int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var role string
		if err := rows.Scan(&role); err != nil {
			return nil, err
		}
		items = append(items, role)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const invalidateAccessTokenChain = `-- name: InvalidateAccessTokenChain :exec
UPDATE access_tokens SET valid = 0 WHERE user_id = ? AND chain = ?
`

type InvalidateAccessTokenChainParams struct {
	UserID int32
	Chain  string
}

func (q *Queries) InvalidateAccessTokenChain(ctx context.Context, arg InvalidateAccessTokenChainParams) error {
	_, err := q.db.ExecContext(ctx, invalidateAccessTokenChain, arg.UserID, arg.Chain)
	return err
}

const invalidateAccessTokens = `-- name: InvalidateAccessTokens :exec
UPDATE access_tokens SET valid = 0 WHERE user_id = ?
`

func (q *Queries) InvalidateAccessTokens(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, invalidateAccessTokens, userID)
	return err
}

const invalidateRefreshToken = `-- name: InvalidateRefreshToken :exec
UPDATE refresh_tokens SET valid = 0 WHERE user_id = ? AND token = ? LIMIT 1
`

type InvalidateRefreshTokenParams struct {
	UserID int32
	Token  string
}

func (q *Queries) InvalidateRefreshToken(ctx context.Context, arg InvalidateRefreshTokenParams) error {
	_, err := q.db.ExecContext(ctx, invalidateRefreshToken, arg.UserID, arg.Token)
	return err
}

const invalidateRefreshTokenChain = `-- name: InvalidateRefreshTokenChain :exec
UPDATE refresh_tokens SET valid = 0 WHERE user_id = ? AND chain = ?
`

type InvalidateRefreshTokenChainParams struct {
	UserID int32
	Chain  string
}

func (q *Queries) InvalidateRefreshTokenChain(ctx context.Context, arg InvalidateRefreshTokenChainParams) error {
	_, err := q.db.ExecContext(ctx, invalidateRefreshTokenChain, arg.UserID, arg.Chain)
	return err
}

const invalidateRefreshTokens = `-- name: InvalidateRefreshTokens :exec
UPDATE refresh_tokens SET valid = 0 WHERE user_id = ?
`

func (q *Queries) InvalidateRefreshTokens(ctx context.Context, userID int32) error {
	_, err := q.db.ExecContext(ctx, invalidateRefreshTokens, userID)
	return err
}

const pruneAccessTokens = `-- name: PruneAccessTokens :exec
DELETE FROM access_tokens WHERE created_at < ?
`

func (q *Queries) PruneAccessTokens(ctx context.Context, createdAt time.Time) error {
	_, err := q.db.ExecContext(ctx, pruneAccessTokens, createdAt)
	return err
}

const pruneRefreshTokens = `-- name: PruneRefreshTokens :exec
DELETE FROM refresh_tokens WHERE created_at < ?
`

func (q *Queries) PruneRefreshTokens(ctx context.Context, createdAt time.Time) error {
	_, err := q.db.ExecContext(ctx, pruneRefreshTokens, createdAt)
	return err
}

const removeOAuth2Identity = `-- name: RemoveOAuth2Identity :exec
DELETE FROM user_identities WHERE user_id = ? AND provider = ? AND identity = ? LIMIT 1
`

type RemoveOAuth2IdentityParams struct {
	UserID   int32
	Provider string
	Identity string
}

func (q *Queries) RemoveOAuth2Identity(ctx context.Context, arg RemoveOAuth2IdentityParams) error {
	_, err := q.db.ExecContext(ctx, removeOAuth2Identity, arg.UserID, arg.Provider, arg.Identity)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users SET email = ?, password = ?, totp_secret = ?, confirmed = ?, confirm_token = ?, recovery_token = ?, locked_until = ?, attempts = ?, last_attempt = ? WHERE id = ?
`

type UpdateUserParams struct {
	Email         string
	Password      sql.NullString
	TotpSecret    sql.NullString
	Confirmed     int32
	ConfirmToken  sql.NullString
	RecoveryToken sql.NullString
	LockedUntil   sql.NullTime
	Attempts      int32
	LastAttempt   sql.NullTime
	ID            int64
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser,
		arg.Email,
		arg.Password,
		arg.TotpSecret,
		arg.Confirmed,
		arg.ConfirmToken,
		arg.RecoveryToken,
		arg.LockedUntil,
		arg.Attempts,
		arg.LastAttempt,
		arg.ID,
	)
	return err
}
